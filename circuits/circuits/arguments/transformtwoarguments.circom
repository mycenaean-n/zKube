// // 'TRANSFORMTWO_YELLOW_YELLOW_RED',
//         else if (index == 10) {
//             return [
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0],
//                 [1, 1, 1, 2],
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0]
//             ];
//         } 
//         // 'TRANSFORMTWO_YELLOW_YELLOW_BLUE',
//         else if (index == 11) {
//             return [
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0],
//                 [1, 1, 1, 3],
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0]
//             ];
//         } 
//         // 'TRANSFORMTWO_YELLOW_RED_YELLOW',
//         else if (index == 12) {
//             return [
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0],
//                 [1, 1, 2, 1],
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0]
//             ];
//         } 
//         // 'TRANSFORMTWO_YELLOW_RED_BLUE',
//         else if (index == 13) {
//             return [
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0],
//                 [1, 1, 2, 3],
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0]
//             ];
//         } 
//         // 'TRANSFORMTWO_YELLOW_BLUE_YELLOW',
//         else if (index == 14) {
//             return [
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0],
//                 [1, 1, 3, 1],
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0]
//             ];
//         } 
//         // 'TRANSFORMTWO_YELLOW_BLUE_RED',
//         else if (index == 15) {  
//             return [
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0],
//                 [1, 1, 3, 2],
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0]
//             ];
//         } 
//         // 'TRANSFORMTWO_RED_RED_YELLOW',
//         else if (index == 16) {
//             return [
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0],
//                 [1, 2, 2, 1],
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0]
//             ];
//          } 
//         // 'TRANSFORMTWO_RED_RED_BLUE',
//          else if (index == 17) {
//             return [
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0],
//                 [1, 2, 2, 3],
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0]
//             ];
//         } 
//         // 'TRANSFORMTWO_RED_YELLOW_RED',  
//         else if (index == 18) {
//             return [
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0],
//                 [1, 2, 1, 2],
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0]
//             ];
//         } 
//         // 'TRANSFORMTWO_RED_YELLOW_BLUE', 
//         else if (index == 19) {
//             return [
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0],
//                 [1, 2, 1, 3],
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0]
//             ];
//         } 
//         // 'TRANSFORMTWO_RED_BLUE_YELLOW', 
//         else if (index == 20) {
//             return [
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0],
//                 [1, 2, 3, 1],
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0]
//             ];
//         } 
//         // 'TRANSFORMTWO_RED_BLUE_RED',  
//         else if (index == 21) {
//             return [
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0],
//                 [1, 2, 3, 2],
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0]
//             ];
//         } 
//         // 'TRANSFORMTWO_BLUE_BLUE_YELLOW',  
//         else if (index == 22) {
//             return [
//                     [0, 0, 0, 0],
//                     [0, 0, 0, 0],
//                     [1, 3, 3, 1],
//                     [0, 0, 0, 0],
//                     [0, 0, 0, 0]
//             ];
//         } 
//         // 'TRANSFORMTWO_BLUE_BLUE_RED',
//         else if (index == 23) {
//             return [
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0],
//                 [1, 3, 3, 2],
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0]
//             ];
//         } 
//         // 'TRANSFORMTWO_BLUE_YELLOW_BLUE',
//         else if (index == 24) {
//             return [
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0],
//                 [1, 3, 1, 3],
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0]
//             ];
//         } 
//         // 'TRANSFORMTWO_BLUE_YELLOW_RED',
//         else if (index == 25) {
//             return [
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0],
//                 [1, 3, 1, 2],
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0]
//             ];
//         } 
//         // 'TRANSFORMTWO_BLUE_RED_YELLOW',
//         else if (index == 26) {
//             return [
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0],
//                 [1, 3, 2, 1],
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0]
//             ];
//         } 
//         // 'TRANSFORMTWO_BLUE_RED_BLUE',
//         else if (index == 27) {
//             return [
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0],
//                 [1, 3, 2, 3],
//                 [0, 0, 0, 0],
//                 [0, 0, 0, 0]
//             ];
//         } 

pragma circom 2.0.0;
include "../../node_modules/circomlib/circuits/comparators.circom";

template ArgumentsTransformTwoYellowYellowRed() {
    signal input inputIndex;
    signal output out[5][4];
    signal instruction[4] <== [1, 1, 1, 2];
    signal instructionOut[4]; 

    component isEq;
    isEq = IsEqual();
    isEq.in[0] <== inputIndex;
    isEq.in[1] <== 10;

    // if eq 1, then multiply identity
    for (var i = 0; i < 4; i++) {
        instructionOut[i] <== instruction[i] * isEq.out;
    }

    out <== [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        instructionOut,
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
}

template ArgumentsTransformTwoYellowYellowBlue() {
    signal input inputIndex;
    signal output out[5][4];
    signal instruction[4] <== [1, 1, 1, 3];
    signal instructionOut[4]; 

    component isEq;
    isEq = IsEqual();
    isEq.in[0] <== inputIndex;
    isEq.in[1] <== 11;

    // if eq 1, then multiply identity
    for (var i = 0; i < 4; i++) {
        instructionOut[i] <== instruction[i] * isEq.out;
    }

    out <== [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        instructionOut,
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
}

template ArgumentsTransformTwoYellowRedYellow() {
    signal input inputIndex;
    signal output out[5][4];
    signal instruction[4] <== [1, 1, 2, 1];
    signal instructionOut[4]; 

    component isEq;
    isEq = IsEqual();
    isEq.in[0] <== inputIndex;
    isEq.in[1] <== 12;

    // if eq 1, then multiply identity
    for (var i = 0; i < 4; i++) {
        instructionOut[i] <== instruction[i] * isEq.out;
    }

    out <== [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        instructionOut,
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
}

template ArgumentsTransformTwoYellowRedBlue() {
    signal input inputIndex;
    signal output out[5][4];
    signal instruction[4] <== [1, 1, 2, 3];
    signal instructionOut[4]; 

    component isEq;
    isEq = IsEqual();
    isEq.in[0] <== inputIndex;
    isEq.in[1] <== 13;

    // if eq 1, then multiply identity
    for (var i = 0; i < 4; i++) {
        instructionOut[i] <== instruction[i] * isEq.out;
    }
    
    out <== [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        instructionOut,
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
}       

template ArgumentsTransformTwoYellowBlueYellow() {
    signal input inputIndex;
    signal output out[5][4];
    signal instruction[4] <== [1, 1, 3, 1];
    signal instructionOut[4]; 

    component isEq;
    isEq = IsEqual();
    isEq.in[0] <== inputIndex;
    isEq.in[1] <== 14;

    // if eq 1, then multiply identity
    for (var i = 0; i < 4; i++) {
        instructionOut[i] <== instruction[i] * isEq.out;
    }

    out <== [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        instructionOut,
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
}

template ArgumentsTransformTwoYellowBlueRed() {
    signal input inputIndex;
    signal output out[5][4];
    signal instruction[4] <== [1, 1, 3, 2];
    signal instructionOut[4]; 

    component isEq;
    isEq = IsEqual();
    isEq.in[0] <== inputIndex;
    isEq.in[1] <== 15;

    // if eq 1, then multiply identity
    for (var i = 0; i < 4; i++) {
        instructionOut[i] <== instruction[i] * isEq.out;
    }

    out <== [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        instructionOut,
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
}

    template ArgumentsTransformTwoRedRedYellow() {
    signal input inputIndex;
    signal output out[5][4];
    signal instruction[4] <== [1, 2, 2, 1];
    signal instructionOut[4]; 

    component isEq;
    isEq = IsEqual();
    isEq.in[0] <== inputIndex;
    isEq.in[1] <== 16;

    // if eq 1, then multiply identity
    for (var i = 0; i < 4; i++) {
        instructionOut[i] <== instruction[i] * isEq.out;
    }

    out <== [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        instructionOut,
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
}

template ArgumentsTransformTwoRedRedBlue() {
    signal input inputIndex;
    signal output out[5][4];
    signal instruction[4] <== [1, 2, 2, 3];
    signal instructionOut[4]; 

    component isEq;
    isEq = IsEqual();
    isEq.in[0] <== inputIndex;
    isEq.in[1] <== 17;

    // if eq 1, then multiply identity
    for (var i = 0; i < 4; i++) {
        instructionOut[i] <== instruction[i] * isEq.out;
    }

    out <== [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        instructionOut,
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
}

template ArgumentsTransformTwoRedYellowRed() {
    signal input inputIndex;
    signal output out[5][4];
    signal instruction[4] <== [1, 2, 1, 2];
    signal instructionOut[4]; 

    component isEq;
    isEq = IsEqual();
    isEq.in[0] <== inputIndex;
    isEq.in[1] <== 18;

    // if eq 1, then multiply identity
    for (var i = 0; i < 4; i++) {
        instructionOut[i] <== instruction[i] * isEq.out;
    }

    out <== [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        instructionOut,
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
}

template ArgumentsTransformTwoRedYellowBlue() {
    signal input inputIndex;
    signal output out[5][4];
    signal instruction[4] <== [1, 2, 1, 3];
    signal instructionOut[4]; 

    component isEq;
    isEq = IsEqual();
    isEq.in[0] <== inputIndex;
    isEq.in[1] <== 19;

    // if eq 1, then multiply identity
    for (var i = 0; i < 4; i++) {
        instructionOut[i] <== instruction[i] * isEq.out;
    }

    out <== [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        instructionOut,
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
}

template ArgumentsTransformTwoRedBlueYellow() {
    signal input inputIndex;
    signal output out[5][4];
    signal instruction[4] <== [1, 2, 3, 1];
    signal instructionOut[4]; 

    component isEq;
    isEq = IsEqual();
    isEq.in[0] <== inputIndex;
    isEq.in[1] <== 20;

    // if eq 1, then multiply identity
    for (var i = 0; i < 4; i++) {
        instructionOut[i] <== instruction[i] * isEq.out;
    }

    out <== [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        instructionOut,
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
}

template ArgumentsTransformTwoRedBlueRed() {
    signal input inputIndex;
    signal output out[5][4];
    signal instruction[4] <== [1, 2, 3, 2];
    signal instructionOut[4]; 

    component isEq;
    isEq = IsEqual();
    isEq.in[0] <== inputIndex;
    isEq.in[1] <== 21;

    // if eq 1, then multiply identity
    for (var i = 0; i < 4; i++) {
        instructionOut[i] <== instruction[i] * isEq.out;
    }
    
    out <== [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        instructionOut,
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
}

template ArgumentsTransformTwoBlueBlueYellow() {
    signal input inputIndex;
    signal output out[5][4];
    signal instruction[4] <== [1, 3, 3, 1];
    signal instructionOut[4]; 

    component isEq;
    isEq = IsEqual();
    isEq.in[0] <== inputIndex;
    isEq.in[1] <== 22;

    // if eq 1, then multiply identity
    for (var i = 0; i < 4; i++) {
        instructionOut[i] <== instruction[i] * isEq.out;
    }
    
    out <== [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        instructionOut,
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
}   

template ArgumentsTransformTwoBlueBlueRed() {
    signal input inputIndex;
    signal output out[5][4];
    signal instruction[4] <== [1, 3, 3, 2];
    signal instructionOut[4]; 

    component isEq;
    isEq = IsEqual();
    isEq.in[0] <== inputIndex;
    isEq.in[1] <== 23;

    // if eq 1, then multiply identity
    for (var i = 0; i < 4; i++) {
        instructionOut[i] <== instruction[i] * isEq.out;
    }
    
    out <== [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        instructionOut,
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
}

template ArgumentsTransformTwoBlueYellowBlue() {
    signal input inputIndex;
    signal output out[5][4];
    signal instruction[4] <== [1, 3, 1, 3];
    signal instructionOut[4]; 

    component isEq;
    isEq = IsEqual();
    isEq.in[0] <== inputIndex;
    isEq.in[1] <== 24;

    // if eq 1, then multiply identity
    for (var i = 0; i < 4; i++) {
        instructionOut[i] <== instruction[i] * isEq.out;
    }
    
    out <== [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        instructionOut,
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
}

template ArgumentsTransformTwoBlueYellowRed() {
    signal input inputIndex;
    signal output out[5][4];
    signal instruction[4] <== [1, 3, 1, 2];
    signal instructionOut[4]; 

    component isEq;
    isEq = IsEqual();
    isEq.in[0] <== inputIndex;
    isEq.in[1] <== 25;

    // if eq 1, then multiply identity
    for (var i = 0; i < 4; i++) {
        instructionOut[i] <== instruction[i] * isEq.out;
    }
    
    out <== [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        instructionOut,
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
}

template ArgumentsTransformTwoBlueRedYellow() {  
    signal input inputIndex;
    signal output out[5][4];
    signal instruction[4] <== [1, 3, 1, 3];
    signal instructionOut[4]; 

    component isEq;
    isEq = IsEqual();
    isEq.in[0] <== inputIndex;
    isEq.in[1] <== 26;

    // if eq 1, then multiply identity
    for (var i = 0; i < 4; i++) {
        instructionOut[i] <== instruction[i] * isEq.out;
    }
    
    out <== [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        instructionOut,
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
}   

template ArgumentsTransformTwoBlueRedRed() {
    signal input inputIndex;
    signal output out[5][4];
    signal instruction[4] <== [1, 3, 2, 2];
    signal instructionOut[4]; 

    component isEq;
    isEq = IsEqual();
    isEq.in[0] <== inputIndex;
    isEq.in[1] <== 27;

    // if eq 1, then multiply identity
    for (var i = 0; i < 4; i++) {
        instructionOut[i] <== instruction[i] * isEq.out;
    }
    
    out <== [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        instructionOut,
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
}
